# üéØ Tropical TCG Players - Contexto del Proyecto

## üìã Descripci√≥n General
**Tropical TCG Players** es una aplicaci√≥n web React completa para una comunidad local de jugadores de Trading Card Games (TCG) en Costa Rica. La plataforma permite a los usuarios comprar, vender, intercambiar cartas y gestionar sus colecciones de m√∫ltiples TCGs.

## üõ†Ô∏è Stack Tecnol√≥gico

### Frontend
- **React 18** con Create React App
- **Bootstrap 5.3** + React Bootstrap para UI
- **React Router** para navegaci√≥n
- **Firebase SDK** para autenticaci√≥n y base de datos
- **Framer Motion** para animaciones
- **React Icons** para iconograf√≠a

### Backend/Servicios
- **Firebase Firestore** - Base de datos NoSQL
- **Firebase Authentication** - Autenticaci√≥n de usuarios
- **APIs Externas:** Multiple TCG APIs para datos de cartas

### Servicios de API
- **Pokemon TCG API v2** (https://api.pokemontcg.io/v2/)
- **TCG APIs** (https://apitcg.com/api/) para otros juegos

## üìÅ Estructura del Proyecto

### Componentes Principales
```
src/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ CardDetailModal.js      # Modal detallado de cartas (RECIENTEMENTE MEJORADO)
‚îÇ   ‚îú‚îÄ‚îÄ SellCardModal.js        # Modal para vender cartas
‚îÇ   ‚îú‚îÄ‚îÄ MarketplaceFilters.js   # Filtros del marketplace
‚îÇ   ‚îú‚îÄ‚îÄ LatestCards.js          # √öltimas cartas a√±adidas
‚îÇ   ‚îî‚îÄ‚îÄ FeaturedSections.js     # Secciones destacadas
‚îú‚îÄ‚îÄ pages/
‚îÇ   ‚îú‚îÄ‚îÄ Marketplace.js          # Marketplace principal (RECIENTEMENTE OPTIMIZADO)
‚îÇ   ‚îú‚îÄ‚îÄ CreateListing.js        # Crear listados de venta
‚îÇ   ‚îú‚îÄ‚îÄ Dashboard.js            # Panel de usuario
‚îÇ   ‚îî‚îÄ‚îÄ BinderView.js           # Vista de carpetas/binders
‚îú‚îÄ‚îÄ contexts/
‚îÇ   ‚îî‚îÄ‚îÄ CartContext.js          # Contexto global del carrito
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îî‚îÄ‚îÄ apiSearchService.js     # Servicio de b√∫squeda de APIs (RECIENTEMENTE ARREGLADO)
‚îî‚îÄ‚îÄ styles/
    ‚îî‚îÄ‚îÄ fonts.css               # Estilos globales y glassmorphism
```

## üóÉÔ∏è Estructura de la Base de Datos (Firebase Firestore) - ACTUALIZADA P2P

### Colecciones Principales

#### `users` *(ACTUALIZADA)*
```javascript
{
  uid: string,
  email: string,
  displayName: string,
  username: string,
  phone: string,                    // REQUERIDO + verificado
  cedula: string,                   // NUEVO: C√©dula obligatoria
  location: string,
  createdAt: timestamp,
  cart: array,                      // Carrito de compras
  binders: array,                   // IDs de carpetas
  listings: array,                  // IDs de listados activos
  rating: number,                   // Calificaci√≥n promedio
  reviews: number,                  // N√∫mero de rese√±as
  completedSales: number,           // NUEVO: Contador de ventas
  completedPurchases: number,       // NUEVO: Contador de compras
  recommendations: number,          // NUEVO: Cantidad de "likes" recibidos
  verificationStatus: {             // NUEVO: Estado de verificaci√≥n
    phone: boolean,
    cedula: boolean,
    email: boolean
  },
  suspensionStatus: {               // NUEVO: Sistema de sanciones
    suspended: boolean,
    reason: string,
    until: timestamp
  }
}
```

#### `listings` *(ACTUALIZADA)*
```javascript
{
  cardId: string,        
  cardName: string,      
  cardImage: string,     
  tcgType: string,       
  setName: string,       
  rarity: string,        
  price: number,         
  condition: string,     
  quantity: number,      
  availableQuantity: number,         // Disponible para venta
  reservedQuantity: number,          // NUEVO: En transacciones pendientes
  description: string,   
  location: string,      
  sellerId: string,      
  sellerName: string,    
  userPhone: string,     
  userEmail: string,
  shippingIncluded: boolean,         // NUEVO: Si incluye env√≠o gratis
  originStore: string,               // NUEVO: Tienda de origen
  status: string,                    // 'active', 'sold_out', 'inactive'
  createdAt: timestamp,
  updatedAt: timestamp,
  reservations: [                    // NUEVO: Array de reservas activas
    {
      transactionId: string,
      quantity: number,
      expiresAt: timestamp
    }
  ]
}
```

#### `transactions` *(COMPLETAMENTE REDISE√ëADA)*
```javascript
{
  id: string,                       // ID √∫nico de transacci√≥n
  buyerId: string,                  // UID del comprador
  sellerId: string,                 // UID del vendedor
  buyerName: string,                // Nombre del comprador
  sellerName: string,               // Nombre del vendedor
  
  items: [                          // Items de la transacci√≥n
    {
      listingId: string,
      cardId: string,
      cardName: string,
      cardImage: string,
      quantity: number,
      price: number,
      condition: string
    }
  ],
  
  totalAmount: number,              // Total en colones
  shippingCost: number,             // Costo de env√≠o (‚Ç°600 o ‚Ç°0)
  finalTotal: number,               // Total + env√≠o
  
  status: string,                   // Ver estados completos abajo
  
  timeline: {                       // Timeline completo de la transacci√≥n
    created: timestamp,
    sellerDeadline: timestamp,      // +24h desde created
    sellerResponded: timestamp,
    deliveryDeadline: timestamp,    // +6 d√≠as desde accepted
    delivered: timestamp,
    paymentRequested: timestamp,
    paymentConfirmed: timestamp,
    buyerDeadline: timestamp,       // +10 d√≠as desde delivered
    buyerConfirmed: timestamp,
    ratingDeadline: timestamp,      // +7 d√≠as desde confirmed
    completed: timestamp
  },
  
  deliveryInfo: {                   // Informaci√≥n de entrega
    originStore: string,            // Tienda donde deja vendedor
    destinationStore: string,       // Tienda donde recoge comprador
    deliveryProof: {                // Foto de prueba
      imageUrl: string,
      uploadedAt: timestamp
    }
  },
  
  paymentInfo: {                    // Informaci√≥n de pago
    method: string,                 // 'sinpe', 'cash', 'trade', 'other'
    paymentProof: {                 // Comprobante del vendedor
      imageUrl: string,
      uploadedAt: timestamp
    },
    buyerConfirmed: boolean         // Si comprador confirm√≥ pago
  },
  
  ratings: {                        // Calificaciones mutuas
    buyerToSeller: {
      stars: number,                // 1-5
      comment: string,              // Opcional
      timestamp: timestamp
    },
    sellerToBuyer: {
      stars: number,
      comment: string,
      timestamp: timestamp
    }
  },
  
  cancellationInfo: {               // Info si se cancela
    cancelledBy: string,            // 'buyer', 'seller', 'system', 'admin'
    reason: string,
    timestamp: timestamp
  },
  
  contactMethod: string,            // 'whatsapp' (principal)
  buyerNotes: string,               // Notas del comprador
  
  createdAt: timestamp,
  updatedAt: timestamp
}
```

### **üÜï NUEVAS COLECCIONES REQUERIDAS**

#### `pendingTransactions`
```javascript
{
  id: string,                       // Mismo ID que en transactions
  listingReservations: [            // Reservas de inventario
    {
      listingId: string,
      reservedQuantity: number,
      expiresAt: timestamp          // Para liberaci√≥n autom√°tica
    }
  ],
  status: string,                   // Para tracking de reservas
  createdAt: timestamp
}
```

#### `notifications`
```javascript
{
  id: string,
  userId: string,                   // Destinatario
  type: string,                     // Tipo de notificaci√≥n
  title: string,                    // T√≠tulo
  message: string,                  // Mensaje completo
  
  relatedTransaction: string,       // ID de transacci√≥n relacionada
  
  channels: {                       // Canales de env√≠o
    inApp: boolean,                 // Mostrar in-app
    whatsapp: boolean,              // Enviar por WhatsApp
    email: boolean,                 // Enviar por email
    sms: boolean                    // Enviar por SMS (futuro)
  },
  
  deliveryStatus: {                 // Estado de entrega
    inApp: {
      sent: boolean,
      read: boolean,
      readAt: timestamp
    },
    whatsapp: {
      sent: boolean,
      delivered: boolean,
      error: string
    },
    email: {
      sent: boolean,
      delivered: boolean,
      error: string
    }
  },
  
  actionRequired: boolean,          // Si requiere acci√≥n del usuario
  actionUrl: string,                // URL para acci√≥n requerida
  
  priority: string,                 // 'low', 'medium', 'high', 'urgent'
  expiresAt: timestamp,             // Para limpiar notificaciones viejas
  
  createdAt: timestamp
}
```

#### `disputes`
```javascript
{
  id: string,
  transactionId: string,            // Transacci√≥n en disputa
  reportedBy: string,               // UID de quien reporta
  reportedAgainst: string,          // UID del reportado
  
  type: string,                     // Tipo de disputa
  category: string,                 // Categor√≠a espec√≠fica
  description: string,              // Descripci√≥n del problema
  
  evidence: [                       // Evidencia adjunta
    {
      type: string,                 // 'image', 'screenshot', 'text'
      url: string,                  // URL del archivo (si aplica)
      description: string           // Descripci√≥n de la evidencia
    }
  ],
  
  status: string,                   // 'open', 'investigating', 'resolved', 'closed'
  priority: string,                 // 'low', 'medium', 'high'
  
  adminNotes: string,               // Notas internas del admin
  resolution: string,               // Resoluci√≥n final
  actionsTaken: string,             // Acciones correctivas aplicadas
  
  createdAt: timestamp,
  resolvedAt: timestamp
}
```

#### `userRecommendations`
```javascript
{
  id: string,
  recommendedUserId: string,        // Usuario recomendado
  recommendingUserId: string,       // Usuario que recomienda
  createdAt: timestamp
}
```

#### `stores` *(NUEVA - Red de Tiendas)*
```javascript
{
  id: string,
  name: string,                     // Nombre de la tienda
  province: string,                 // Provincia
  city: string,                     // Ciudad
  address: string,                  // Direcci√≥n completa
  phone: string,                    // Tel√©fono de contacto
  email: string,                    // Email
  
  operatingHours: {                 // Horarios
    monday: { open: string, close: string },
    tuesday: { open: string, close: string },
    // ... resto de d√≠as
    sunday: { open: string, close: string }
  },
  
  isActive: boolean,                // Si est√° operativa
  acceptsDeliveries: boolean,       // Si acepta entregas de vendedores
  acceptsPickups: boolean,          // Si permite recoger compras
  
  createdAt: timestamp,
  updatedAt: timestamp
}
```

### **üìä ESTADOS DE TRANSACCI√ìN COMPLETOS**
```javascript
const TRANSACTION_STATES = {
  // Fase inicial
  'pending_seller_response': 'Esperando respuesta del vendedor (24h)',
  
  // Vendedor acepta
  'accepted_pending_delivery': 'Aceptada, pendiente de entrega (6 d√≠as)',
  'delivered_pending_payment': 'Entregada, pendiente de pago',
  'payment_confirmed': 'Pago confirmado, pendiente recibo comprador (10 d√≠as)',
  
  // Estados finales
  'completed': 'Transacci√≥n completada con ratings',
  'completed_no_rating': 'Completada sin calificaci√≥n mutua',
  
  // Cancelaciones
  'cancelled_by_seller': 'Cancelada por vendedor',
  'cancelled_by_buyer': 'Cancelada por comprador', 
  'cancelled_timeout_seller': 'Cancelada por timeout vendedor (24h)',
  'cancelled_timeout_delivery': 'Cancelada por timeout entrega (6 d√≠as)',
  'cancelled_by_admin': 'Cancelada por administrador',
  
  // Disputas
  'disputed': 'En disputa - bajo investigaci√≥n',
  'resolved_favour_buyer': 'Disputa resuelta a favor del comprador',
  'resolved_favour_seller': 'Disputa resuelta a favor del vendedor'
};
```

## üîó APIs y Documentaci√≥n

### Documentaci√≥n de APIs TCG
- **Ubicaci√≥n:** `.claude/TCG APIS DOCUMENTATION.txt`
- **APIs Soportadas:**
  - Pok√©mon TCG (api.pokemontcg.io)
  - One Piece TCG (apitcg.com)
  - Dragon Ball Fusion (apitcg.com)
  - Digimon TCG (apitcg.com)
  - Magic: The Gathering (apitcg.com)
  - Union Arena (apitcg.com)
  - Gundam TCG (apitcg.com)

### Variables de Entorno Requeridas
```
REACT_APP_POKEMON_API_KEY=your_pokemon_api_key
REACT_APP_TCG_API_KEY=your_tcg_api_key
```

## üé® Sistema de Dise√±o

### Tema Visual
- **Glassmorphism** - Efectos de cristal con `backdrop-filter: blur()`
- **Transparencias** - `rgba()` para fondos semi-transparentes
- **Tipograf√≠a** - Montserrat Alternates para t√≠tulos, Montserrat para texto
- **Background** - Imagen "background celeeste.png"

### Componentes Estilizados
- Cards transparentes con bordes redondeados
- Botones con efectos glassmorphism
- Modales con background blur
- Badges y elementos con transparencias

## üöÄ Funcionalidades Implementadas

### ‚úÖ Completadas
1. **Sistema de Autenticaci√≥n** - Firebase Auth completo
2. **Marketplace Avanzado** - B√∫squeda multi-API con 48 resultados por p√°gina
3. **Modal de Cartas Mejorado** - 3 pesta√±as: Detalles, Precios, Vendedores
4. **Carrito de Compras** - Contexto global con Firebase sync
5. **Sistema de Listados** - Crear/editar/gestionar ventas
6. **B√∫squeda de APIs** - Servicio unificado para todos los TCGs
7. **Sistema de Carpetas** - Binders personalizables
8. **Formateo de Datos** - JSON objects convertidos a texto limpio

### üîß Funcionalidades Principales

#### Marketplace (`src/pages/Marketplace.js`)
- B√∫squeda espec√≠fica por TCG (obligatorio seleccionar juego)
- 48 cartas por p√°gina (incrementado recientemente)
- Filtros avanzados con sidebar
- Integraci√≥n con vendedores locales
- Precios comparativos

#### Modal de Cartas (`src/components/CardDetailModal.js`)
- **Header:** Nombre centrado y grande + bot√≥n coraz√≥n para favoritos
- **Pesta√±a Detalles:** Informaci√≥n espec√≠fica por TCG
- **Pesta√±a Precios:** TCGPlayer.com + Mercado CR (ponderado local)
- **Pesta√±a Vendedores:** Lista completa con contacto y carrito
- Fondo glassmorphism en toda la interfaz

#### Servicio de APIs (`src/services/apiSearchService.js`)
- B√∫squeda unificada en m√∫ltiples TCG APIs
- Normalizaci√≥n de datos entre diferentes APIs
- Formateo autom√°tico de objetos complejos (sets, precios)
- Cache inteligente y fallbacks

## üêõ Problemas Resueltos Recientemente

### Formateo de Objetos JSON ‚úÖ
- **Problema:** Las APIs devolv√≠an objetos complejos que se mostraban como JSON crudo
- **Soluci√≥n:** Implementado `formatSetInfo()` y `safeString()` para mostrar texto limpio
- **Resultado:** Ahora muestra "Champion's Path, Sword & Shield" en lugar de JSON

### L√≠mites de B√∫squeda ‚úÖ
- **Problema:** Solo 12 resultados por b√∫squeda
- **Soluci√≥n:** Incrementado a 48 cartas por p√°gina + m√≠nimo 50 por API
- **Resultado:** M√°s cartas disponibles en cada b√∫squeda

### Restructuraci√≥n de Modal ‚úÖ
- **Problema:** Interfaz desorganizada, pesta√±as inconsistentes
- **Soluci√≥n:** 3 pesta√±as uniformes para todos los TCG, bot√≥n favoritos optimizado
- **Resultado:** UX consistente y profesional

## üîÑ **NUEVO FLUJO P2P COMPLETO - EN IMPLEMENTACI√ìN**

### üéØ **FLUJO DE COMPRA/VENTA PEER-TO-PEER**

Se ha definido un **sistema completo de transacciones P2P** que reemplaza el sistema b√°sico anterior:

#### **FASES DEL FLUJO:**
1. **üõí COMPRA:** Carrito multi-vendedor ‚Üí Checkout separado por vendedor
2. **‚è∞ RESPUESTA (24h):** Vendedor acepta/rechaza ‚Üí Auto-cancel si no responde  
3. **üì¶ ENTREGA (6 d√≠as):** Red de tiendas CR ‚Üí Foto de confirmaci√≥n obligatoria
4. **üí≥ PAGO:** Templates WhatsApp ‚Üí Comprobante obligatorio
5. **üìã CONFIRMACI√ìN (10 d√≠as):** Comprador confirma recibo ‚Üí Auto-confirmar
6. **‚≠ê RATINGS:** Calificaci√≥n mutua obligatoria (7 d√≠as) + Sistema de recomendaciones

### **üÜï NUEVAS FUNCIONALIDADES REQUERIDAS:**

#### **A. SISTEMA DE TRANSACCIONES AVANZADO**
- **Estados m√∫ltiples:** 8 estados diferentes con timeouts autom√°ticos
- **Verificaci√≥n at√≥mica:** Prevenci√≥n de sobreventa con reservas temporales
- **Gesti√≥n de inventario:** Restauraci√≥n autom√°tica en cancelaciones
- **Checkout multi-vendedor:** UI separada por vendedor con opciones de env√≠o

#### **B. SISTEMA DE NOTIFICACIONES COMPLETO**
- **WhatsApp API:** Templates autom√°ticos para cada fase
- **Email backup:** Integraci√≥n con Brevo API
- **In-app notifications:** Notificaciones tiempo real
- **Cloud Functions:** Timers autom√°ticos y auto-cancelaciones

#### **C. SISTEMA DE SEGURIDAD Y VERIFICACI√ìN**
- **Verificaci√≥n obligatoria:** C√©dula + tel√©fono para todos los usuarios
- **Fotos de prueba:** Validaci√≥n de entregas con datos del comprador
- **Sistema anti-fraude:** Tracking de comportamiento + penalizaciones
- **Una cuenta por c√©dula:** Prevenci√≥n de cuentas m√∫ltiples

#### **D. SISTEMA DE REPUTACI√ìN AVANZADO**
- **Ratings mutuos:** Comprador ‚Üî Vendedor obligatorios
- **Sistema de recomendaciones:** "Likes" reversibles a perfiles
- **Consecuencias visibles:** Mayor/menor visibilidad seg√∫n rating
- **Perfil p√∫blico completo:** Stats detalladas de cada usuario

#### **E. SISTEMA DE ENV√çOS**
- **Red de tiendas:** 2+ tiendas por provincia en Costa Rica
- **Gesti√≥n manual:** Sistema de tracking propio (futuro)
- **Costos fijos:** ‚Ç°600 por env√≠o entre tiendas
- **Selecci√≥n flexible:** Vendedor elige origen, comprador elige destino

#### **F. SISTEMA DE DISPUTAS Y MODERACI√ìN**
- **Reportes estructurados:** Diferentes tipos de disputas
- **Panel admin:** Herramientas de moderaci√≥n y resoluci√≥n
- **Medidas correctivas:** Warnings ‚Üí suspensiones ‚Üí bans permanentes
- **Investigaci√≥n con evidencia:** Screenshots, fotos, historiales

### **üìä ESTADO ACTUAL DE IMPLEMENTACI√ìN:**

#### **‚úÖ COMPLETADO (Base Existente):**
- Sistema b√°sico de carrito y transacciones
- Autenticaci√≥n con Firebase
- Marketplace con b√∫squeda multi-API
- Modal de cartas con vendedores
- Base de datos estructurada

#### **üîÑ EN PLANIFICACI√ìN (Este Sprint):**
- **Nuevas colecciones BD:** `pendingTransactions`, `notifications`, `disputes`, `userRecommendations`
- **Cloud Functions:** Timeouts autom√°ticos, env√≠o de notificaciones
- **UI Components:** Checkout multi-vendedor, modales de rating, panel de transacciones
- **API Integration:** WhatsApp Business API, Email API (Brevo)
- **Security Layer:** Verificaci√≥n de c√©dula, validaci√≥n de fotos

## üìã Pendientes para Producci√≥n

### üéØ Pr√≥ximas Mejoras
1. **Modo Offline** - PWA con Service Workers
2. **An√°lisis de Precios** - Gr√°ficos hist√≥ricos de precios
3. **Sistema de Intercambios** - Trading entre usuarios
4. **Wishlist Avanzada** - Notificaciones de cartas deseadas
5. **Geolocalizaci√≥n** - Vendedores cercanos

### üîß Optimizaciones T√©cnicas
1. **Code Splitting** - Lazy loading de componentes
2. **Image Optimization** - WebP y lazy loading
3. **Bundle Analysis** - Reducir tama√±o de app
4. **Performance Monitoring** - Analytics y m√©tricas

## üéÆ TCGs Soportados

| TCG | API | Status | Campos Espec√≠ficos |
|-----|-----|--------|-------------------|
| Pok√©mon | Pokemon TCG API v2 | ‚úÖ Activo | HP, tipos, ataques, habilidades |
| One Piece | TCG APIs | ‚úÖ Activo | Costo, poder, counter, familia |
| Dragon Ball | TCG APIs | ‚úÖ Activo | Poder, costo, caracter√≠sticas |
| Digimon | TCG APIs | ‚úÖ Activo | DP, nivel, atributo |
| Magic | TCG APIs | ‚úÖ Activo | Costo, tipo, habilidades |
| Union Arena | TCG APIs | ‚úÖ Activo | AP, BP, efecto |
| Gundam | TCG APIs | ‚úÖ Activo | HP, nivel, zona |

## üöÄ Comandos de Desarrollo

```bash
# Instalar dependencias
npm install

# Desarrollo local
npm start

# Build para producci√≥n
npm run build

# Ejecutar tests
npm test

# Linting (si est√° configurado)
npm run lint

# Type checking (si est√° configurado) 
npm run typecheck
```

## üìù Notas para Sesiones Futuras

### Estado Actual del Proyecto
- **Modal de cartas:** Completamente optimizado y listo para producci√≥n
- **Marketplace:** B√∫squeda funcionando con 48 resultados por p√°gina
- **APIs:** Formateo de datos funcionando correctamente
- **Base de datos:** Estructura estable y escalable

### Pr√≥ximos Pasos Recomendados
1. **Sistema de calificaciones** para vendedores
2. **Optimizaci√≥n de rendimiento** (lazy loading, code splitting)
3. **Panel de administraci√≥n** para moderaci√≥n
4. **Sistema de pagos** integrado
5. **Testing automatizado** (Jest, Cypress)

### **üìÇ ARCHIVOS CR√çTICOS PARA EL NUEVO FLUJO P2P**

#### **üîÑ ARCHIVOS A MODIFICAR**
- `src/contexts/CartContext.js` - Extender con l√≥gica de reservas y transacciones P2P
- `src/pages/Marketplace.js` - Integrar con nuevo sistema de disponibilidad
- `src/components/SellCardModal.js` - Agregar opci√≥n de env√≠o incluido

#### **üÜï ARCHIVOS A CREAR**
- `src/contexts/TransactionContext.js` - Contexto para manejo de transacciones P2P
- `src/components/TransactionModal.js` - Modal principal de gesti√≥n de transacciones
- `src/components/CheckoutMultiVendor.js` - Checkout separado por vendedor
- `src/components/RatingModal.js` - Modal de calificaciones mutuas
- `src/components/NotificationPanel.js` - Panel de notificaciones in-app
- `src/components/DisputeModal.js` - Modal para reportar disputas
- `src/pages/TransactionDashboard.js` - Dashboard de transacciones del usuario
- `src/services/notificationService.js` - Servicio de notificaciones
- `src/services/whatsappService.js` - Integraci√≥n con WhatsApp API
- `src/hooks/useTransactions.js` - Hook personalizado para transacciones
- `src/utils/transactionHelpers.js` - Utilidades y helpers

#### **‚òÅÔ∏è CLOUD FUNCTIONS A CREAR**
- `functions/transactionTimeouts.js` - Auto-cancelar transacciones vencidas
- `functions/notificationSender.js` - Env√≠o autom√°tico de notificaciones
- `functions/inventoryManager.js` - Gesti√≥n autom√°tica de inventario
- `functions/ratingEnforcer.js` - Penalizar usuarios sin calificar

#### **üóÇÔ∏è ARCHIVOS DE CONFIGURACI√ìN**
- `.env` - Agregar WhatsApp API keys, Brevo API keys
- `firebase.json` - Configurar nuevas Cloud Functions
- `firestore.rules` - Actualizar reglas de seguridad para nuevas colecciones

### **üöÄ PLAN DE IMPLEMENTACI√ìN RECOMENDADO**

#### **Sprint 1: Base de Datos y Backend**
1. Crear nuevas colecciones en Firestore
2. Actualizar colecciones existentes
3. Implementar Cloud Functions b√°sicas
4. Configurar APIs externas (WhatsApp, Email)

#### **Sprint 2: Contextos y Servicios**
1. Crear TransactionContext
2. Extender CartContext
3. Implementar servicios de notificaci√≥n
4. Crear hooks personalizados

#### **Sprint 3: UI/UX Components**
1. Checkout multi-vendedor
2. Dashboard de transacciones
3. Modales de rating y disputas
4. Panel de notificaciones

#### **Sprint 4: Integraci√≥n y Testing**
1. Integrar todos los componentes
2. Testing exhaustivo de flujos
3. Optimizaci√≥n y pulimiento
4. Deploy y monitoreo

---

## üöÄ **PLAN DETALLADO DE IMPLEMENTACI√ìN - 4 SPRINTS**

### **üìã INSTRUCCIONES PARA CONTINUIDAD DE IA:**

**IMPORTANTE:** Este plan permite a cualquier IA continuar la implementaci√≥n desde cualquier punto. Cada sprint es independiente y tiene todo el contexto necesario.

**CONTEXTO REQUERIDO:**
- Leer completamente `Context.md` y `CLAUDE.md`
- Entender flujo P2P de 6 fases definido
- Conocer estructura actual del proyecto React + Firebase
- Revisar c√≥digo existente en `src/contexts/CartContext.js` y `src/pages/Marketplace.js`

---

## üèóÔ∏è **SPRINT 1: FOUNDATION - BASE DE DATOS Y BACKEND**
**Duraci√≥n estimada:** 3-4 d√≠as
**Objetivo:** Crear infraestructura backend completa para el sistema P2P

### **FASE 1.1: ACTUALIZACI√ìN DE COLECCIONES EXISTENTES** ‚è±Ô∏è 1 d√≠a

#### **A. Actualizar colecci√≥n `users`**
```javascript
// ACCI√ìN: Agregar campos nuevos a documentos existentes
// UBICACI√ìN: Firebase Console o Cloud Function de migraci√≥n

// CAMPOS A AGREGAR:
{
  cedula: string,                   // C√©dula verificada
  completedSales: 0,               // Inicializar en 0
  completedPurchases: 0,           // Inicializar en 0  
  recommendations: 0,              // Inicializar en 0
  verificationStatus: {            // Estado verificaci√≥n
    phone: false,
    cedula: false,
    email: true                    // Ya verificado por Firebase Auth
  },
  suspensionStatus: {              // Sistema sanciones
    suspended: false,
    reason: "",
    until: null
  }
}

// MIGRACI√ìN REQUERIDA:
// 1. Crear Cloud Function: migrateUsers()
// 2. Ejecutar sobre todos los documentos usuarios existentes
// 3. Mantener compatibilidad con c√≥digo actual
```

#### **B. Actualizar colecci√≥n `listings`**
```javascript
// ACCI√ìN: Extender estructura de listings

// CAMPOS A AGREGAR:
{
  reservedQuantity: 0,             // Cantidad reservada en transacciones
  shippingIncluded: false,         // Por defecto sin env√≠o incluido
  originStore: "",                 // Tienda de origen (vac√≠o inicialmente)
  reservations: []                 // Array vac√≠o inicialmente
}

// MIGRACI√ìN:
// 1. Funci√≥n: migrateListings()
// 2. Verificar que availableQuantity = quantity - reservedQuantity
// 3. Mantener compatibilidad con SellCardModal.js existente
```

#### **C. Reestructurar colecci√≥n `transactions`**
```javascript
// ACCI√ìN: Migrar transacciones existentes al nuevo formato

// MIGRACI√ìN COMPLEJA REQUERIDA:
// 1. Backup de transactions actuales
// 2. Crear nuevas transactions con formato P2P completo
// 3. Mapear campos antiguos a nuevos:
//    - buyerId, buyerName, items ‚Üí mantener
//    - status ‚Üí convertir a nuevos estados P2P
//    - agregar campos: timeline, deliveryInfo, paymentInfo, ratings
```

### **FASE 1.2: CREAR NUEVAS COLECCIONES** ‚è±Ô∏è 0.5 d√≠as

#### **A. Colecci√≥n `pendingTransactions`**
```javascript
// PROP√ìSITO: Manejar reservas temporales de inventario
// CREACI√ìN: Autom√°tica con primera transacci√≥n P2P

// REGLAS FIRESTORE REQUERIDAS:
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /pendingTransactions/{transactionId} {
      allow read, write: if request.auth != null 
        && (request.auth.uid == resource.data.buyerId 
        || request.auth.uid == resource.data.sellerId);
    }
  }
}
```

#### **B. Colecci√≥n `notifications`**
```javascript
// PROP√ìSITO: Sistema notificaciones multi-canal
// √çNDICES REQUERIDOS:
// - userId + createdAt (desc) 
// - type + createdAt (desc)
// - expiresAt (para cleanup autom√°tico)

// REGLAS FIRESTORE:
match /notifications/{notificationId} {
  allow read, write: if request.auth != null 
    && request.auth.uid == resource.data.userId;
}
```

#### **C. Colecciones adicionales**
```javascript
// disputes, userRecommendations, stores
// Ver especificaci√≥n completa en secci√≥n "Base de Datos"
// Crear con reglas de seguridad apropiadas
```

### **FASE 1.3: CLOUD FUNCTIONS B√ÅSICAS** ‚è±Ô∏è 2 d√≠as

#### **A. Funci√≥n: transactionTimeouts.js**
```javascript
// UBICACI√ìN: functions/transactionTimeouts.js
// TRIGGER: Pub/Sub cada 5 minutos

const functions = require('firebase-functions');
const admin = require('firebase-admin');

exports.processTimeouts = functions.pubsub
  .schedule('every 5 minutes')
  .onRun(async (context) => {
    const now = admin.firestore.Timestamp.now();
    
    // 1. Buscar transacciones con sellerDeadline vencida
    const expiredSellerResponse = await admin.firestore()
      .collection('transactions')
      .where('status', '==', 'pending_seller_response')
      .where('timeline.sellerDeadline', '<', now)
      .get();
      
    // 2. Auto-cancelar y restaurar inventario
    for (const doc of expiredSellerResponse.docs) {
      await cancelTransactionAndRestoreInventory(doc.id, 'timeout_seller');
    }
    
    // 3. Repetir para otros timeouts: delivery, rating, etc.
    // Ver implementaci√≥n completa requerida
  });

// FUNCI√ìN HELPER CR√çTICA:
async function cancelTransactionAndRestoreInventory(transactionId, reason) {
  // 1. Obtener transaction data
  // 2. Restaurar availableQuantity en listings
  // 3. Eliminar reservations
  // 4. Actualizar estado transaction
  // 5. Crear notificaci√≥n para usuario
  // 6. Aplicar penalizaci√≥n si corresponde
}
```

#### **B. Funci√≥n: notificationSender.js**
```javascript
// UBICACI√ìN: functions/notificationSender.js
// TRIGGER: Firestore onCreate en /notifications/{notificationId}

exports.sendNotification = functions.firestore
  .document('notifications/{notificationId}')
  .onCreate(async (snap, context) => {
    const notification = snap.data();
    
    // 1. WhatsApp (si channels.whatsapp = true)
    if (notification.channels.whatsapp) {
      await sendWhatsApp(notification);
    }
    
    // 2. Email (si channels.email = true)  
    if (notification.channels.email) {
      await sendEmail(notification);
    }
    
    // 3. Actualizar deliveryStatus
    await snap.ref.update({
      'deliveryStatus.inApp.sent': true
    });
  });

// APIs REQUERIDAS:
// - WhatsApp Business API
// - Brevo/SendGrid para email
// Variables de entorno en .env
```

### **FASE 1.4: CONFIGURACI√ìN DE APIS EXTERNAS** ‚è±Ô∏è 0.5 d√≠as

#### **A. Variables de entorno requeridas (.env)**
```bash
# WhatsApp Business API
REACT_APP_WHATSAPP_API_URL=https://graph.facebook.com/v17.0/
REACT_APP_WHATSAPP_ACCESS_TOKEN=tu_token_aqui
REACT_APP_WHATSAPP_PHONE_ID=tu_phone_id

# Email API (Brevo)
REACT_APP_BREVO_API_KEY=tu_api_key
REACT_APP_BREVO_SENDER_EMAIL=noreply@tropicaltcg.com

# Firebase Functions
FIREBASE_PROJECT_ID=tu-proyecto-id
```

#### **B. Configurar firebase.json**
```json
{
  "functions": {
    "source": "functions",
    "runtime": "nodejs18",
    "predeploy": ["npm --prefix functions run build"]
  },
  "firestore": {
    "rules": "firestore.rules",
    "indexes": "firestore.indexes.json"
  }
}
```

### **ENTREGABLES SPRINT 1:**
‚úÖ Colecciones actualizadas y migradas
‚úÖ 6 nuevas colecciones creadas con reglas de seguridad
‚úÖ 2 Cloud Functions deployadas y funcionando
‚úÖ APIs externas configuradas y probadas
‚úÖ Variables de entorno documentadas

---

## üîß **SPRINT 2: SERVICIOS Y CONTEXTOS**
**Duraci√≥n estimada:** 3-4 d√≠as  
**Objetivo:** Crear l√≥gica de negocio y contextos React para P2P

### **FASE 2.1: EXTENDER CARTCONTEXT** ‚è±Ô∏è 1.5 d√≠as

#### **A. Agregar funciones de reserva**
```javascript
// UBICACI√ìN: src/contexts/CartContext.js
// AGREGAR AL CONTEXTO EXISTENTE:

// NUEVA FUNCI√ìN: createPendingTransaction()
const createPendingTransaction = async (vendorItems, destinationStore) => {
  try {
    // 1. Verificar disponibilidad at√≥mica de todos los items
    const availability = await Promise.all(
      vendorItems.map(item => checkAtomicAvailability(item.listingId, item.quantity))
    );
    
    if (!availability.every(a => a.available)) {
      throw new Error('Algunos items ya no est√°n disponibles');
    }
    
    // 2. Crear reservas temporales
    const reservations = await createTemporaryReservations(vendorItems);
    
    // 3. Crear transaction con estado pending_seller_response
    const transaction = await createTransactionDocument(vendorItems, destinationStore);
    
    // 4. Programar timeout autom√°tico (24h)
    await scheduleSellerTimeout(transaction.id);
    
    // 5. Enviar notificaci√≥n al vendedor
    await createSellerNotification(transaction);
    
    return transaction.id;
    
  } catch (error) {
    // Rollback cualquier reserva creada
    await rollbackReservations(reservations);
    throw error;
  }
};

// FUNCI√ìN CR√çTICA: checkAtomicAvailability()
const checkAtomicAvailability = async (listingId, requestedQuantity) => {
  return await admin.firestore().runTransaction(async (transaction) => {
    const listingRef = admin.firestore().doc(`listings/${listingId}`);
    const listing = await transaction.get(listingRef);
    
    if (!listing.exists) {
      return { available: false, reason: 'Listing no existe' };
    }
    
    const data = listing.data();
    const available = (data.availableQuantity || 0) - (data.reservedQuantity || 0);
    
    if (available >= requestedQuantity) {
      // Incrementar reservedQuantity at√≥micamente
      transaction.update(listingRef, {
        reservedQuantity: (data.reservedQuantity || 0) + requestedQuantity
      });
      return { available: true };
    } else {
      return { available: false, reason: `Solo ${available} disponibles` };
    }
  });
};
```

#### **B. Actualizar funciones existentes**
```javascript
// MODIFICAR: addToCart() existente
// AGREGAR: Validaciones de reservas activas
// MODIFICAR: removeFromCart() existente  
// AGREGAR: Liberar reservas si es necesario

// NUEVA FUNCI√ìN: getCartByVendor()
const getCartByVendor = () => {
  const cartByVendor = {};
  cart.forEach(item => {
    const vendorId = item.sellerId;
    if (!cartByVendor[vendorId]) {
      cartByVendor[vendorId] = {
        vendor: {
          id: vendorId,
          name: item.sellerName,
          location: item.location
        },
        items: [],
        totalAmount: 0,
        shippingCost: 0,
        finalTotal: 0
      };
    }
    cartByVendor[vendorId].items.push(item);
    cartByVendor[vendorId].totalAmount += item.price * item.quantity;
    
    // Calcular env√≠o (‚Ç°600 si no est√° incluido)
    if (!item.shippingIncluded) {
      cartByVendor[vendorId].shippingCost = 600;
    }
    cartByVendor[vendorId].finalTotal = 
      cartByVendor[vendorId].totalAmount + cartByVendor[vendorId].shippingCost;
  });
  return cartByVendor;
};
```

### **FASE 2.2: CREAR TRANSACTIONCONTEXT** ‚è±Ô∏è 1.5 d√≠as

#### **A. Nuevo contexto completo**
```javascript
// UBICACI√ìN: src/contexts/TransactionContext.js
// CREAR ARCHIVO NUEVO

import React, { createContext, useContext, useState, useEffect } from 'react';
import { useCart } from './CartContext';

const TransactionContext = createContext();

export function TransactionProvider({ children }) {
  const [userTransactions, setUserTransactions] = useState([]);
  const [activeTransactions, setActiveTransactions] = useState([]);
  const [loading, setLoading] = useState(false);
  const { user } = useCart();

  // FUNCI√ìN: getUserTransactions()
  const getUserTransactions = async () => {
    if (!user) return;
    
    setLoading(true);
    try {
      // Obtener transacciones donde el usuario es comprador O vendedor
      const buyerQuery = query(
        collection(db, 'transactions'),
        where('buyerId', '==', user.uid),
        orderBy('createdAt', 'desc')
      );
      
      const sellerQuery = query(
        collection(db, 'transactions'),  
        where('sellerId', '==', user.uid),
        orderBy('createdAt', 'desc')
      );
      
      const [buyerDocs, sellerDocs] = await Promise.all([
        getDocs(buyerQuery),
        getDocs(sellerQuery)
      ]);
      
      const allTransactions = [
        ...buyerDocs.docs.map(doc => ({ id: doc.id, ...doc.data(), userRole: 'buyer' })),
        ...sellerDocs.docs.map(doc => ({ id: doc.id, ...doc.data(), userRole: 'seller' }))
      ];
      
      // Ordenar por fecha
      allTransactions.sort((a, b) => b.createdAt.seconds - a.createdAt.seconds);
      
      setUserTransactions(allTransactions);
      
      // Filtrar transacciones activas (no completadas/canceladas)
      const active = allTransactions.filter(t => 
        !['completed', 'cancelled_by_seller', 'cancelled_by_buyer', 'cancelled_timeout_seller'].includes(t.status)
      );
      setActiveTransactions(active);
      
    } catch (error) {
      console.error('Error getting transactions:', error);
    }
    setLoading(false);
  };

  // FUNCI√ìN: updateTransactionStatus()
  const updateTransactionStatus = async (transactionId, newStatus, additionalData = {}) => {
    try {
      const updateData = {
        status: newStatus,
        updatedAt: new Date(),
        ...additionalData
      };
      
      await updateDoc(doc(db, 'transactions', transactionId), updateData);
      
      // Refrescar transacciones
      await getUserTransactions();
      
      return true;
    } catch (error) {
      console.error('Error updating transaction:', error);
      return false;
    }
  };

  // FUNCI√ìN: acceptTransaction() - Para vendedores
  const acceptTransaction = async (transactionId, originStore) => {
    try {
      const now = new Date();
      const deliveryDeadline = new Date(now.getTime() + (6 * 24 * 60 * 60 * 1000)); // +6 d√≠as
      
      const success = await updateTransactionStatus(transactionId, 'accepted_pending_delivery', {
        'timeline.sellerResponded': now,
        'timeline.deliveryDeadline': deliveryDeadline,
        'deliveryInfo.originStore': originStore
      });
      
      if (success) {
        // Crear notificaci√≥n para comprador
        await createBuyerNotification(transactionId, 'transaction_accepted');
        // Programar timeout de entrega
        await scheduleDeliveryTimeout(transactionId);
      }
      
      return success;
    } catch (error) {
      console.error('Error accepting transaction:', error);
      return false;
    }
  };

  // FUNCI√ìN: rejectTransaction() - Para vendedores  
  const rejectTransaction = async (transactionId, reason) => {
    try {
      const success = await updateTransactionStatus(transactionId, 'cancelled_by_seller', {
        'timeline.sellerResponded': new Date(),
        'cancellationInfo.cancelledBy': 'seller',
        'cancellationInfo.reason': reason,
        'cancellationInfo.timestamp': new Date()
      });
      
      if (success) {
        // Restaurar inventario
        await restoreTransactionInventory(transactionId);
        // Notificar comprador
        await createBuyerNotification(transactionId, 'transaction_rejected');
      }
      
      return success;
    } catch (error) {
      console.error('Error rejecting transaction:', error);
      return false;
    }
  };

  // ... [m√°s funciones: confirmDelivery, confirmPayment, submitRating, etc.]

  return (
    <TransactionContext.Provider value={{
      userTransactions,
      activeTransactions,
      loading,
      getUserTransactions,
      updateTransactionStatus,
      acceptTransaction,
      rejectTransaction,
      // ... m√°s funciones
    }}>
      {children}
    </TransactionContext.Provider>
  );
}

export function useTransactions() {
  return useContext(TransactionContext);
}
```

### **FASE 2.3: SERVICIOS DE NOTIFICACI√ìN** ‚è±Ô∏è 1 d√≠a

#### **A. Servicio de notificaciones**
```javascript
// UBICACI√ìN: src/services/notificationService.js
// CREAR ARCHIVO NUEVO

class NotificationService {
  // FUNCI√ìN: createNotification()
  async createNotification(userId, type, title, message, options = {}) {
    const notification = {
      userId,
      type,
      title,
      message,
      relatedTransaction: options.transactionId || null,
      channels: {
        inApp: true,
        whatsapp: options.whatsapp || false,
        email: options.email || false,
        sms: false
      },
      deliveryStatus: {
        inApp: { sent: false, read: false, readAt: null },
        whatsapp: { sent: false, delivered: false, error: null },
        email: { sent: false, delivered: false, error: null }
      },
      actionRequired: options.actionRequired || false,
      actionUrl: options.actionUrl || null,
      priority: options.priority || 'medium',
      expiresAt: options.expiresAt || null,
      createdAt: new Date()
    };
    
    try {
      const docRef = await addDoc(collection(db, 'notifications'), notification);
      return docRef.id;
    } catch (error) {
      console.error('Error creating notification:', error);
      throw error;
    }
  }

  // FUNCI√ìN: getWhatsAppUrl()
  getWhatsAppUrl(phone, message) {
    const cleanPhone = phone.replace(/\D/g, '');
    const encodedMessage = encodeURIComponent(message);
    return `https://wa.me/${cleanPhone}?text=${encodedMessage}`;
  }

  // TEMPLATES PREDEFINIDOS
  getTemplate(type, data) {
    const templates = {
      seller_new_purchase: {
        title: "üéØ Nueva compra",
        message: `Tienes una nueva solicitud de compra de ${data.cardName} por ‚Ç°${data.price}. Tienes 24 horas para responder.`,
        whatsapp: true
      },
      buyer_accepted: {
        title: "‚úÖ Compra aceptada", 
        message: `Tu compra de ${data.cardName} fue aceptada por ${data.sellerName}. Coordinen la entrega.`,
        whatsapp: true
      },
      // ... m√°s templates
    };
    
    return templates[type] || null;
  }
}

export default new NotificationService();
```

### **ENTREGABLES SPRINT 2:**
‚úÖ CartContext extendido con funciones P2P
‚úÖ TransactionContext completo creado
‚úÖ NotificationService implementado
‚úÖ WhatsAppService b√°sico funcionando  
‚úÖ Hooks personalizados creados

---

## üé® **SPRINT 3: COMPONENTES UI/UX**
**Duraci√≥n estimada:** 4-5 d√≠as
**Objetivo:** Crear interfaces completas para el flujo P2P

### **FASE 3.1: CHECKOUT MULTI-VENDEDOR** ‚è±Ô∏è 2 d√≠as

#### **A. Componente principal**
```javascript
// UBICACI√ìN: src/components/CheckoutMultiVendor.js
// CREAR ARCHIVO NUEVO

import React, { useState } from 'react';
import { Modal, Button, Card, Row, Col, Form } from 'react-bootstrap';
import { useCart } from '../contexts/CartContext';
import StoreSelector from './StoreSelector';

export default function CheckoutMultiVendor({ show, onHide }) {
  const { cart, getCartByVendor } = useCart();
  const [selectedStores, setSelectedStores] = useState({});
  const [processing, setProcessing] = useState(false);
  
  const cartByVendor = getCartByVendor();

  const handleConfirmPurchase = async (vendorId) => {
    setProcessing(true);
    try {
      const vendorCart = cartByVendor[vendorId];
      const destinationStore = selectedStores[vendorId];
      
      if (!destinationStore) {
        alert('Selecciona una tienda de destino');
        return;
      }
      
      // Crear transacci√≥n P2P
      const transactionId = await createPendingTransaction(vendorCart.items, destinationStore);
      
      if (transactionId) {
        // Remover items del carrito
        vendorCart.items.forEach(item => removeFromCart(item.listingId));
        
        alert(`Solicitud enviada a ${vendorCart.vendor.name}. Te notificaremos su respuesta.`);
      }
    } catch (error) {
      alert('Error procesando compra: ' + error.message);
    }
    setProcessing(false);
  };

  return (
    <Modal show={show} onHide={onHide} size="lg" centered>
      <Modal.Header closeButton>
        <Modal.Title>üõí Confirmar Compras</Modal.Title>
      </Modal.Header>
      <Modal.Body>
        {Object.entries(cartByVendor).map(([vendorId, vendorData]) => (
          <Card key={vendorId} className="mb-4">
            <Card.Header>
              <h5>üì¶ {vendorData.vendor.name}</h5>
              <small className="text-muted">{vendorData.vendor.location}</small>
            </Card.Header>
            <Card.Body>
              {/* Lista de items */}
              {vendorData.items.map(item => (
                <Row key={item.listingId} className="align-items-center mb-2">
                  <Col md={2}>
                    <img src={item.cardImage} alt={item.cardName} style={{width: '40px'}} />
                  </Col>
                  <Col md={6}>
                    <strong>{item.cardName}</strong>
                    <br />
                    <small>{item.condition} - {item.setName}</small>
                  </Col>
                  <Col md={2}>
                    {item.quantity}x
                  </Col>
                  <Col md={2}>
                    ‚Ç°{(item.price * item.quantity).toLocaleString()}
                  </Col>
                </Row>
              ))}
              
              <hr />
              
              {/* Resumen de costos */}
              <Row>
                <Col md={8}>
                  <strong>Subtotal:</strong><br />
                  <strong>Env√≠o:</strong><br />
                  <h5>Total:</h5>
                </Col>
                <Col md={4} className="text-end">
                  ‚Ç°{vendorData.totalAmount.toLocaleString()}<br />
                  {vendorData.shippingCost > 0 ? `‚Ç°${vendorData.shippingCost}` : 'Gratis'}<br />
                  <h5>‚Ç°{vendorData.finalTotal.toLocaleString()}</h5>
                </Col>
              </Row>
              
              {/* Selector de tienda */}
              <Form.Group className="mt-3">
                <Form.Label>Tienda de destino:</Form.Label>
                <StoreSelector 
                  selectedStore={selectedStores[vendorId]}
                  onStoreSelect={(store) => setSelectedStores({...selectedStores, [vendorId]: store})}
                />
              </Form.Group>
              
              {/* Bot√≥n de confirmaci√≥n */}
              <Button 
                variant="success" 
                className="w-100 mt-3"
                onClick={() => handleConfirmPurchase(vendorId)}
                disabled={processing || !selectedStores[vendorId]}
              >
                {processing ? 'Procesando...' : `Confirmar compra con ${vendorData.vendor.name}`}
              </Button>
            </Card.Body>
          </Card>
        ))}
      </Modal.Body>
    </Modal>
  );
}
```

#### **B. Componente selector de tiendas**
```javascript
// UBICACI√ìN: src/components/StoreSelector.js
// CREAR ARCHIVO NUEVO

import React, { useState, useEffect } from 'react';
import { Form } from 'react-bootstrap';
import { collection, getDocs, where, query } from 'firebase/firestore';
import { db } from '../firebase';

export default function StoreSelector({ selectedStore, onStoreSelect }) {
  const [stores, setStores] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchStores = async () => {
      try {
        const storesQuery = query(
          collection(db, 'stores'),
          where('isActive', '==', true),
          where('acceptsPickups', '==', true)
        );
        
        const storesSnapshot = await getDocs(storesQuery);
        const storesData = storesSnapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        }));
        
        setStores(storesData);
      } catch (error) {
        console.error('Error fetching stores:', error);
      }
      setLoading(false);
    };

    fetchStores();
  }, []);

  const handleStoreChange = (e) => {
    const storeId = e.target.value;
    const store = stores.find(s => s.id === storeId);
    onStoreSelect(store);
  };

  if (loading) return <Form.Select disabled><option>Cargando tiendas...</option></Form.Select>;

  return (
    <Form.Select value={selectedStore?.id || ''} onChange={handleStoreChange}>
      <option value="">Selecciona una tienda...</option>
      {stores.map(store => (
        <option key={store.id} value={store.id}>
          {store.name} - {store.city}, {store.province}
        </option>
      ))}
    </Form.Select>
  );
}
```

### **FASE 3.2: DASHBOARD DE TRANSACCIONES** ‚è±Ô∏è 2 d√≠as

#### **A. P√°gina principal del dashboard**
```javascript
// UBICACI√ìN: src/pages/TransactionDashboard.js  
// CREAR ARCHIVO NUEVO

import React, { useEffect, useState } from 'react';
import { Container, Row, Col, Card, Badge, Button, Tabs, Tab } from 'react-bootstrap';
import { useTransactions } from '../contexts/TransactionContext';
import TransactionCard from '../components/TransactionCard';
import RatingModal from '../components/RatingModal';

export default function TransactionDashboard() {
  const { userTransactions, activeTransactions, loading, getUserTransactions } = useTransactions();
  const [selectedTransaction, setSelectedTransaction] = useState(null);
  const [showRatingModal, setShowRatingModal] = useState(false);

  useEffect(() => {
    getUserTransactions();
  }, []);

  const getStatusBadge = (status) => {
    const statusMap = {
      'pending_seller_response': { variant: 'warning', text: 'Esperando vendedor' },
      'accepted_pending_delivery': { variant: 'info', text: 'Pendiente entrega' },
      'delivered_pending_payment': { variant: 'primary', text: 'Pendiente pago' },
      'payment_confirmed': { variant: 'success', text: 'Pago confirmado' },
      'completed': { variant: 'success', text: 'Completada' },
      // ... m√°s estados
    };
    
    return statusMap[status] || { variant: 'secondary', text: status };
  };

  const getActionButton = (transaction) => {
    const { status, userRole } = transaction;
    
    if (userRole === 'seller' && status === 'pending_seller_response') {
      return (
        <Button 
          variant="success" 
          size="sm"
          onClick={() => handleSellerResponse(transaction.id)}
        >
          Responder
        </Button>
      );
    }
    
    if (userRole === 'seller' && status === 'accepted_pending_delivery') {
      return (
        <Button 
          variant="primary" 
          size="sm"
          onClick={() => handleConfirmDelivery(transaction.id)}
        >
          Confirmar Entrega
        </Button>
      );
    }
    
    if (status === 'completed' && !transaction.ratings?.[userRole === 'buyer' ? 'buyerToSeller' : 'sellerToBuyer']) {
      return (
        <Button 
          variant="warning" 
          size="sm"
          onClick={() => openRatingModal(transaction)}
        >
          Calificar
        </Button>
      );
    }
    
    return null;
  };

  return (
    <Container className="py-4">
      <h2>üìä Mis Transacciones</h2>
      
      <Tabs defaultActiveKey="active" className="mb-4">
        <Tab eventKey="active" title={`Activas (${activeTransactions.length})`}>
          <Row>
            {activeTransactions.map(transaction => (
              <Col key={transaction.id} md={6} lg={4} className="mb-3">
                <TransactionCard 
                  transaction={transaction}
                  onAction={getActionButton(transaction)}
                />
              </Col>
            ))}
          </Row>
        </Tab>
        
        <Tab eventKey="all" title={`Todas (${userTransactions.length})`}>
          <Row>
            {userTransactions.map(transaction => (
              <Col key={transaction.id} md={6} lg={4} className="mb-3">
                <TransactionCard 
                  transaction={transaction}
                  onAction={getActionButton(transaction)}
                />
              </Col>
            ))}
          </Row>
        </Tab>
        
        <Tab eventKey="completed" title="Completadas">
          {/* Filtrar solo completadas */}
        </Tab>
      </Tabs>

      {/* Modal de calificaci√≥n */}
      <RatingModal 
        show={showRatingModal}
        onHide={() => setShowRatingModal(false)}
        transaction={selectedTransaction}
      />
    </Container>
  );
}
```

### **FASE 3.3: MODAL DE CALIFICACIONES** ‚è±Ô∏è 1 d√≠a

#### **A. Modal de rating completo**
```javascript
// UBICACI√ìN: src/components/RatingModal.js
// CREAR ARCHIVO NUEVO

import React, { useState } from 'react';
import { Modal, Button, Form, Row, Col } from 'react-bootstrap';
import { FaStar } from 'react-icons/fa';
import { useTransactions } from '../contexts/TransactionContext';

export default function RatingModal({ show, onHide, transaction }) {
  const [rating, setRating] = useState(0);
  const [hoverRating, setHoverRating] = useState(0);
  const [comment, setComment] = useState('');
  const [submitting, setSubmitting] = useState(false);
  
  const { submitRating } = useTransactions();

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (rating === 0) {
      alert('Debes seleccionar una calificaci√≥n');
      return;
    }
    
    setSubmitting(true);
    try {
      await submitRating(transaction.id, rating, comment.trim());
      alert('Calificaci√≥n enviada exitosamente');
      onHide();
    } catch (error) {
      alert('Error enviando calificaci√≥n: ' + error.message);
    }
    setSubmitting(false);
  };

  const isOtherUser = transaction?.userRole === 'buyer' ? 
    transaction.sellerName : 
    transaction.buyerName;

  return (
    <Modal show={show} onHide={onHide} centered>
      <Modal.Header closeButton>
        <Modal.Title>‚≠ê Calificar Transacci√≥n</Modal.Title>
      </Modal.Header>
      <Form onSubmit={handleSubmit}>
        <Modal.Body>
          <div className="text-center mb-4">
            <h5>¬øC√≥mo fue tu experiencia con {isOtherUser}?</h5>
            <p className="text-muted">Tu calificaci√≥n es obligatoria para completar la transacci√≥n</p>
          </div>
          
          {/* Sistema de estrellas */}
          <div className="text-center mb-4">
            {[1, 2, 3, 4, 5].map((star) => (
              <FaStar
                key={star}
                size={32}
                style={{ 
                  cursor: 'pointer', 
                  color: star <= (hoverRating || rating) ? '#ffc107' : '#e4e5e9',
                  marginRight: '8px'
                }}
                onClick={() => setRating(star)}
                onMouseEnter={() => setHoverRating(star)}
                onMouseLeave={() => setHoverRating(0)}
              />
            ))}
          </div>
          
          {/* Labels para estrellas */}
          <div className="text-center mb-4">
            {rating > 0 && (
              <p className="mb-0">
                {rating === 1 && "üòû Muy malo"}
                {rating === 2 && "üôÅ Malo"}  
                {rating === 3 && "üòê Regular"}
                {rating === 4 && "üôÇ Bueno"}
                {rating === 5 && "üòÑ Excelente"}
              </p>
            )}
          </div>
          
          {/* Comentario opcional */}
          <Form.Group>
            <Form.Label>Comentario (opcional)</Form.Label>
            <Form.Control
              as="textarea"
              rows={3}
              placeholder="Comparte tu experiencia con otros usuarios..."
              value={comment}
              onChange={(e) => setComment(e.target.value)}
              maxLength={500}
            />
            <Form.Text className="text-muted">
              {comment.length}/500 caracteres
            </Form.Text>
          </Form.Group>
          
          {/* Resumen de la transacci√≥n */}
          {transaction && (
            <div className="bg-light p-3 rounded mt-3">
              <h6>Resumen de la transacci√≥n:</h6>
              <small>
                ‚Ä¢ {transaction.items?.length} item(s)<br />
                ‚Ä¢ Total: ‚Ç°{transaction.finalTotal?.toLocaleString()}<br />
                ‚Ä¢ Fecha: {transaction.createdAt?.toDate?.()?.toLocaleDateString()}
              </small>
            </div>
          )}
        </Modal.Body>
        <Modal.Footer>
          <Button variant="outline-secondary" onClick={onHide} disabled={submitting}>
            Cancelar
          </Button>
          <Button variant="success" type="submit" disabled={submitting || rating === 0}>
            {submitting ? 'Enviando...' : 'Enviar Calificaci√≥n'}
          </Button>
        </Modal.Footer>
      </Form>
    </Modal>
  );
}
```

### **ENTREGABLES SPRINT 3:**
‚úÖ CheckoutMultiVendor funcionando completamente
‚úÖ TransactionDashboard con todas las vistas
‚úÖ RatingModal con sistema de estrellas
‚úÖ StoreSelector integrado
‚úÖ NotificationPanel b√°sico implementado

---

## üîó **SPRINT 4: INTEGRACI√ìN Y TESTING**
**Duraci√≥n estimada:** 2-3 d√≠as
**Objetivo:** Integrar todo y realizar testing exhaustivo

### **FASE 4.1: INTEGRACI√ìN COMPLETA** ‚è±Ô∏è 1.5 d√≠as

#### **A. Actualizar componentes existentes**
```javascript
// MODIFICAR: src/components/SellCardModal.js
// AGREGAR: Campo para incluir env√≠o
<Form.Check 
  type="checkbox"
  label="Incluir env√≠o gratis (‚Ç°600)"
  checked={shippingIncluded}
  onChange={(e) => setShippingIncluded(e.target.checked)}
/>

// AGREGAR: Selector de tienda de origen  
<Form.Group>
  <Form.Label>Tienda de origen (donde dejar√°s la carta)</Form.Label>
  <StoreSelector 
    selectedStore={originStore}
    onStoreSelect={setOriginStore}
    filterBy="acceptsDeliveries"
  />
</Form.Group>
```

```javascript
// MODIFICAR: src/pages/Marketplace.js
// ACTUALIZAR: L√≥gica de disponibilidad
// CONSIDERAR: reservedQuantity en c√°lculos
const actualAvailable = listing.availableQuantity - (listing.reservedQuantity || 0);
```

#### **B. Integrar contextos**
```javascript
// MODIFICAR: src/App.js
// AGREGAR: TransactionProvider

import { TransactionProvider } from './contexts/TransactionContext';

function App() {
  return (
    <CartProvider>
      <TransactionProvider>
        {/* resto de la app */}
      </TransactionProvider>
    </CartProvider>
  );
}
```

### **FASE 4.2: TESTING DE FLUJOS** ‚è±Ô∏è 1 d√≠a

#### **A. Test del flujo completo P2P**
```javascript
// CREAR: src/tests/p2pFlow.test.js
// PRUEBAS REQUERIDAS:

// 1. Test compra exitosa completa
describe('P2P Complete Flow', () => {
  test('successful transaction from cart to rating', async () => {
    // 1. Agregar carta al carrito
    // 2. Proceder al checkout multi-vendedor
    // 3. Confirmar compra (crear transacci√≥n)
    // 4. Vendedor acepta
    // 5. Vendedor confirma entrega
    // 6. Comprador confirma recibo
    // 7. Ambos califican
    // 8. Verificar estado final 'completed'
  });
  
  // 2. Test cancelaci√≥n por timeout
  test('seller timeout cancellation', async () => {
    // Simular que pasan 24h sin respuesta del vendedor
    // Verificar auto-cancelaci√≥n
    // Verificar restauraci√≥n de inventario
  });
  
  // 3. Test reservas de inventario
  test('inventory reservation system', async () => {
    // Verificar que reservedQuantity se actualiza
    // Verificar que availableQuantity se reduce
    // Verificar liberaci√≥n en cancelaci√≥n
  });
});
```

#### **B. Testing de componentes**
```javascript
// TESTS M√çNIMOS REQUERIDOS:
// - CheckoutMultiVendor.test.js
// - TransactionDashboard.test.js  
// - RatingModal.test.js
// - StoreSelector.test.js
// - TransactionContext.test.js
```

### **FASE 4.3: OPTIMIZACI√ìN Y DEPLOY** ‚è±Ô∏è 0.5 d√≠as

#### **A. Optimizaciones finales**
```javascript
// 1. Lazy loading de componentes grandes
const TransactionDashboard = lazy(() => import('./pages/TransactionDashboard'));
const CheckoutMultiVendor = lazy(() => import('./components/CheckoutMultiVendor'));

// 2. Memoizaci√≥n de c√°lculos pesados
const cartByVendor = useMemo(() => getCartByVendor(), [cart]);

// 3. Debouncing en b√∫squedas
const debouncedSearch = useCallback(
  debounce((term) => performSearch(term), 300),
  []
);
```

#### **B. Deploy y configuraci√≥n**
```bash
# 1. Deploy Cloud Functions
firebase deploy --only functions

# 2. Deploy Firestore rules
firebase deploy --only firestore:rules

# 3. Deploy aplicaci√≥n  
npm run build
firebase deploy --only hosting

# 4. Configurar variables de entorno en producci√≥n
# 5. Poblar colecci√≥n stores con tiendas reales
# 6. Configurar √≠ndices de Firestore requeridos
```

### **ENTREGABLES SPRINT 4:**
‚úÖ Sistema P2P completamente integrado y funcional
‚úÖ Todos los componentes trabajando juntos  
‚úÖ Testing exhaustivo completado
‚úÖ Deploy en producci√≥n exitoso
‚úÖ Documentaci√≥n actualizada

---

## üìã **CHECKLIST FINAL PARA CONTINUIDAD DE IA**

### **DOCUMENTOS QUE LEER ANTES DE CONTINUAR:**
- [ ] `Context.md` - Especificaci√≥n completa del flujo P2P
- [ ] `CLAUDE.md` - Documentaci√≥n t√©cnica y estructura BD
- [ ] Este plan de sprints completo
- [ ] C√≥digo existente en `src/contexts/CartContext.js`
- [ ] C√≥digo existente en `src/pages/Marketplace.js`

### **VERIFICACIONES ANTES DE EMPEZAR CADA SPRINT:**
- [ ] Firebase est√° configurado y conectado
- [ ] Variables de entorno est√°n definidas
- [ ] Dependencias npm est√°n instaladas
- [ ] Se tiene acceso a Firebase Console
- [ ] Se conoce la estructura actual de las colecciones

### **PUNTOS CR√çTICOS A NO OLVIDAR:**
- [ ] **Atomicidad:** Todas las operaciones de inventario deben ser transaccionales
- [ ] **Timeouts:** Cada transacci√≥n DEBE tener timeouts autom√°ticos
- [ ] **Rollbacks:** Si algo falla, restaurar el estado anterior
- [ ] **Notificaciones:** Crear notificaci√≥n para cada cambio de estado  
- [ ] **Seguridad:** Validar permisos en todas las operaciones

### **ESTADO ACTUAL AL FINALIZAR DOCUMENTACI√ìN:**
- [x] Flujo P2P completamente especificado
- [x] Base de datos dise√±ada con 11 colecciones
- [x] Plan de 4 sprints detallado
- [x] 15+ archivos nuevos planificados
- [x] Cloud Functions especificadas  
- [x] APIs externas identificadas
- [ ] **PR√ìXIMO PASO:** Ejecutar Sprint 1 - Fase 1.1

---

### **üîß RESPUESTA FINAL A IMPLEMENTACI√ìN T√âCNICA:**
1. **Firebase existente es suficiente** - No backend separado necesario
2. **Empezar por Sprint 1** - Base de datos y Cloud Functions primero
3. **Cada sprint es autocontenido** - Puede pausarse/continuarse en cualquier punto
4. **Testing continuo** - Probar cada funcionalidad antes de continuar

--- 
*Status: **Plan Completo de Implementaci√≥n** - Listo para ejecuci√≥n inmediata*